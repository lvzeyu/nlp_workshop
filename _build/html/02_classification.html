

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Text Classification &#8212; Transformersによるセンチメント分析</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '02_classification';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/hf-logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/hf-logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Transformersによるセンチメント分析
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">イントロダクション</a></li>
<li class="toctree-l1"><a class="reference internal" href="fine_tuning.html">転移学習とファインチューニング</a></li>
<li class="toctree-l1"><a class="reference internal" href="huggingface.html">Hugging Face</a></li>
<li class="toctree-l1"><a class="reference internal" href="sentiment.html">センチメント分析の実装</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/lvzeyu/nlp_workshop/blob/master/02_classification.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onColab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/lvzeyu/nlp_workshop" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/lvzeyu/nlp_workshop/issues/new?title=Issue%20on%20page%20%2F02_classification.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/02_classification.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Text Classification</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-dataset">The Dataset</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-first-look-at-hugging-face-datasets">A First Look at Hugging Face Datasets</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sidebar-what-if-my-dataset-is-not-on-the-hub">Sidebar: What If My Dataset Is Not on the Hub?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#end-sidebar">End sidebar</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-datasets-to-dataframes">From Datasets to DataFrames</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#looking-at-the-class-distribution">Looking at the Class Distribution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-long-are-our-tweets">How Long Are Our Tweets?</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#from-text-to-tokens">From Text to Tokens</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#character-tokenization">Character Tokenization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#word-tokenization">Word Tokenization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#subword-tokenization">Subword Tokenization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tokenizing-the-whole-dataset">Tokenizing the Whole Dataset</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#training-a-text-classifier">Training a Text Classifier</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transformers-as-feature-extractors">Transformers as Feature Extractors</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#using-pretrained-models">Using pretrained models</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sidebar-interoperability-between-frameworks">Sidebar: Interoperability Between Frameworks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">End sidebar</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#extracting-the-last-hidden-states">Extracting the last hidden states</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-feature-matrix">Creating a feature matrix</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#visualizing-the-training-set">Visualizing the training set</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#training-a-simple-classifier">Training a simple classifier</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fine-tuning-transformers">Fine-Tuning Transformers</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#loading-a-pretrained-model">Loading a pretrained model</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#defining-the-performance-metrics">Defining the performance metrics</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#training-the-model">Training the model</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sidebar-fine-tuning-with-keras">Sidebar: Fine-Tuning with Keras</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">End sidebar</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#error-analysis">Error analysis</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-and-sharing-the-model">Saving and sharing the model</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion">Conclusion</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Uncomment and run this cell if you&#39;re on Colab or Kaggle</span>
<span class="c1"># !git clone https://github.com/nlp-with-transformers/notebooks.git</span>
<span class="c1"># %cd notebooks</span>
<span class="c1"># from install import *</span>
<span class="c1"># install_requirements(is_chapter2=True)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># hide</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">setup_chapter</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">line</span> <span class="mi">2</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="c1"># hide</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">setup_chapter</span><span class="p">()</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;utils&#39;
</pre></div>
</div>
</div>
</div>
<section class="tex2jax_ignore mathjax_ignore" id="text-classification">
<h1>Text Classification<a class="headerlink" href="#text-classification" title="Permalink to this heading">#</a></h1>
<p>Text classification is one of the most common tasks in NLP; it can be used for a broad range of applications, such as tagging customer feedback into categories or routing support tickets according to their language. Chances are that your email program’s spam filter is using text classification to protect your inbox from a deluge of unwanted junk!</p>
<p>Another common type of text classification is sentiment analysis, which (as we saw in &lt;&lt;chapter_introduction&gt;&gt;) aims to identify the polarity of a given text. For example, a company like Tesla might analyze Twitter posts like the one in &lt;<tesla-tweet>&gt; to determine whether people like its new car roofs or not.</p>
<a class="reference internal image-reference" href="images/chapter02_tweet.png"><img alt="Tesla Tweet" src="images/chapter02_tweet.png" style="width: 500px;" /></a>
<p>Now imagine that you are a data scientist who needs to build a system that can automatically identify emotional states such as “anger” or “joy” that people express about your company’s product on Twitter. In this chapter, we’ll tackle this task using a variant of BERT called DistilBERT.footnote:[V. Sanh et al., <a class="reference external" href="https://arxiv.org/abs/1910.01108">“DistilBERT, a Distilled Version of BERT: Smaller, Faster, Cheaper and Lighter”</a>, (2019).] The main advantage of this model is that it achieves comparable performance to BERT, while being significantly smaller and more efficient. This enables us to train a classifier in a few minutes, and if you want to train a larger BERT model you can simply change the checkpoint of the pretrained model. A <em>checkpoint</em> corresponds to the set of weights that are loaded into a given transformer architecture.</p>
<p>This will also be our first encounter with three of the core libraries from the Hugging Face ecosystem: image:images/logo.png[hf,13,13] Datasets, image:images/logo.png[hf,13,13] Tokenizers, and image:images/logo.png[hf,13,13] Transformers. As shown in  &lt;<hf-libraries>&gt;, these libraries will allow us to quickly go from raw text to a fine-tuned model that can be used for inference on new tweets. So, in the spirit of Optimus Prime, let’s dive in, “transform, and roll out!”footnote:[Optimus Prime is the leader of a race of robots in the popular Transformers franchise for children (and for those who are young at heart!).]</p>
<img alt="Hugging Face Pipeline" src="images/chapter02_hf-libraries.png" />
<section id="the-dataset">
<h2>The Dataset<a class="headerlink" href="#the-dataset" title="Permalink to this heading">#</a></h2>
<p>To build our emotion detector we’ll use a great dataset from an article that explored how emotions are represented in English Twitter messages.footnote:[E. Saravia et al., “CARER: Contextualized Affect Representations for Emotion Recognition,” <em>Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing</em> (Oct–Nov 2018): 3687–3697, <a class="reference external" href="http://dx.doi.org/10.18653/v1/D18-1404.">http://dx.doi.org/10.18653/v1/D18-1404.</a>] Unlike most sentiment analysis datasets that involve just “positive” and “negative” polarities, this dataset contains six basic emotions: anger, disgust, fear, joy, sadness, and surprise. Given a tweet, our task will be to train a model that can classify it into one of these emotions.</p>
<section id="a-first-look-at-hugging-face-datasets">
<h3>A First Look at Hugging Face Datasets<a class="headerlink" href="#a-first-look-at-hugging-face-datasets" title="Permalink to this heading">#</a></h3>
<p>We will use image:images/logo.png[hf,13,13] Datasets to download the data from the <a class="reference external" href="https://huggingface.co/datasets">Hugging Face Hub</a>. We can use the <code class="docutils literal notranslate"><span class="pre">list_datasets()</span></code> function to see what datasets are available on the Hub:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datasets</span> <span class="kn">import</span> <span class="n">list_datasets</span>

<span class="n">all_datasets</span> <span class="o">=</span> <span class="n">list_datasets</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_datasets</span><span class="p">)</span><span class="si">}</span><span class="s2"> datasets currently available on the Hub&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The first 10 are: </span><span class="si">{</span><span class="n">all_datasets</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/home/lyuzeyu/anaconda3/envs/nlp_workshop/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html
  from .autonotebook import tqdm as notebook_tqdm
/tmp/ipykernel_3104/89111038.py:3: FutureWarning: list_datasets is deprecated and will be removed in the next major version of datasets. Use &#39;huggingface_hub.list_datasets&#39; instead.
  all_datasets = list_datasets()
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>There are 61312 datasets currently available on the Hub
The first 10 are: [&#39;acronym_identification&#39;, &#39;ade_corpus_v2&#39;, &#39;adversarial_qa&#39;, &#39;aeslc&#39;, &#39;afrikaans_ner_corpus&#39;, &#39;ag_news&#39;, &#39;ai2_arc&#39;, &#39;air_dialogue&#39;, &#39;ajgt_twitter_ar&#39;, &#39;allegro_reviews&#39;]
</pre></div>
</div>
</div>
</div>
<p>We see that each dataset is given a name, so let’s load the <code class="docutils literal notranslate"><span class="pre">emotion</span></code> dataset with the <code class="docutils literal notranslate"><span class="pre">load_dataset()</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># hide_output</span>
<span class="kn">from</span> <span class="nn">datasets</span> <span class="kn">import</span> <span class="n">load_dataset</span>

<span class="n">emotions</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">(</span><span class="s2">&quot;emotion&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If we look inside our <code class="docutils literal notranslate"><span class="pre">emotions</span></code> object:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">emotions</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DatasetDict({
    train: Dataset({
        features: [&#39;text&#39;, &#39;label&#39;],
        num_rows: 16000
    })
    validation: Dataset({
        features: [&#39;text&#39;, &#39;label&#39;],
        num_rows: 2000
    })
    test: Dataset({
        features: [&#39;text&#39;, &#39;label&#39;],
        num_rows: 2000
    })
})
</pre></div>
</div>
</div>
</div>
<p>we see it is similar to a Python dictionary, with each key corresponding to a different split. And we can use the usual dictionary syntax to access an individual split:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_ds</span> <span class="o">=</span> <span class="n">emotions</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">]</span>
<span class="n">train_ds</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dataset({
    features: [&#39;text&#39;, &#39;label&#39;],
    num_rows: 16000
})
</pre></div>
</div>
</div>
</div>
<p>which returns an instance of the <code class="docutils literal notranslate"><span class="pre">Dataset</span></code> class. The <code class="docutils literal notranslate"><span class="pre">Dataset</span></code> object is one of the core data structures in image:images/logo.png[hf,13,13] Datasets, and we’ll be exploring many of its features throughout the course of this book. For starters, it behaves like an ordinary Python array or list, so we can query its length:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">train_ds</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>16000
</pre></div>
</div>
</div>
</div>
<p>or access a single example by its index:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;text&#39;: &#39;i didnt feel humiliated&#39;, &#39;label&#39;: 0}
</pre></div>
</div>
</div>
</div>
<p>Here we see that a single row is represented as a dictionary, where the keys correspond to the column names:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_ds</span><span class="o">.</span><span class="n">column_names</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;text&#39;, &#39;label&#39;]
</pre></div>
</div>
</div>
</div>
<p>and the values are the tweet and the emotion. This reflects the fact that image:images/logo.png[hf,13,13] Datasets is based on <a class="reference external" href="https://arrow.apache.org/"><em>Apache Arrow</em></a>, which defines a typed columnar format that is more memory efficient than native Python. We can see what data types are being used under the hood by accessing the <code class="docutils literal notranslate"><span class="pre">features</span></code> attribute of a <code class="docutils literal notranslate"><span class="pre">Dataset</span></code> object:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">train_ds</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;text&#39;: Value(dtype=&#39;string&#39;, id=None), &#39;label&#39;: ClassLabel(names=[&#39;sadness&#39;, &#39;joy&#39;, &#39;love&#39;, &#39;anger&#39;, &#39;fear&#39;, &#39;surprise&#39;], id=None)}
</pre></div>
</div>
</div>
</div>
<p>In this case, the data type of the <code class="docutils literal notranslate"><span class="pre">text</span></code> column is <code class="docutils literal notranslate"><span class="pre">string</span></code>, while the <code class="docutils literal notranslate"><span class="pre">label</span></code> column is a special <code class="docutils literal notranslate"><span class="pre">ClassLabel</span></code> object that contains information about the class names and their mapping to integers. We can also access several rows with a slice:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">train_ds</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;text&#39;: [&#39;i didnt feel humiliated&#39;, &#39;i can go from feeling so hopeless to so damned hopeful just from being around someone who cares and is awake&#39;, &#39;im grabbing a minute to post i feel greedy wrong&#39;, &#39;i am ever feeling nostalgic about the fireplace i will know that it is still on the property&#39;, &#39;i am feeling grouchy&#39;], &#39;label&#39;: [0, 0, 3, 2, 3]}
</pre></div>
</div>
</div>
</div>
<p>Note that in this case, the dictionary values are now lists instead of individual elements. We can also get the full column by name:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">train_ds</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">][:</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;i didnt feel humiliated&#39;, &#39;i can go from feeling so hopeless to so damned hopeful just from being around someone who cares and is awake&#39;, &#39;im grabbing a minute to post i feel greedy wrong&#39;, &#39;i am ever feeling nostalgic about the fireplace i will know that it is still on the property&#39;, &#39;i am feeling grouchy&#39;]
</pre></div>
</div>
</div>
</div>
<p>Now that we’ve seen how to load and inspect data with image:images/logo.png[hf,13,13] Datasets, let’s do a few sanity checks about the content of our tweets.</p>
</section>
<section id="sidebar-what-if-my-dataset-is-not-on-the-hub">
<h3>Sidebar: What If My Dataset Is Not on the Hub?<a class="headerlink" href="#sidebar-what-if-my-dataset-is-not-on-the-hub" title="Permalink to this heading">#</a></h3>
<p>We’ll be using the Hugging Face Hub to download datasets for most of the examples in this book. But in many cases, you’ll find yourself working with data that is either stored on your laptop or on a remote server in your organization. image:images/logo.png[hf,13,13] Datasets provides several loading scripts to handle local and remote datasets. Examples for the most common data formats are shown in &lt;<dataset-loading>&gt;.</p>
<div class="highlight-asciidoc notranslate"><div class="highlight"><pre><span></span>[[dataset-loading]]
.How to load datasets in various formats
[options=&quot;header&quot;]
|======
| Data format | Loading script | Example
| CSV | `csv` | `load_dataset(&quot;csv&quot;, data_files=&quot;my_file.csv&quot;)` 
| Text | `text` | `load_dataset(&quot;text&quot;, data_files=&quot;my_file.txt&quot;)` 
| JSON | `json` | `load_dataset(&quot;json&quot;, data_files=&quot;my_file.jsonl&quot;)`
|======
</pre></div>
</div>
<p>As you can see for each data format, we just need to pass the relevant loading script to the <code class="docutils literal notranslate"><span class="pre">load_dataset()</span></code> function, along with a <code class="docutils literal notranslate"><span class="pre">data_files</span></code> argument that specifies the path or URL to one or more files. For example, the source files for the <code class="docutils literal notranslate"><span class="pre">emotion</span></code> dataset are actually hosted on Dropbox, so an alternative way to load the dataset is to first download one of the splits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="c1"># The original URL used in the book is no longer available, so we use a different one</span>
<span class="n">dataset_url</span> <span class="o">=</span> <span class="s2">&quot;https://huggingface.co/datasets/transformersbook/emotion-train-split/raw/main/train.txt&quot;</span>
<span class="o">!</span>wget<span class="w"> </span><span class="o">{</span>dataset_url<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>--2023-09-15 11:59:40--  https://huggingface.co/datasets/transformersbook/emotion-train-split/raw/main/train.txt
Resolving huggingface.co (huggingface.co)... 13.32.50.102, 13.32.50.53, 13.32.50.129, ...
Connecting to huggingface.co (huggingface.co)|13.32.50.102|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 1658616 (1.6M) [text/plain]
Saving to: ‘train.txt’

train.txt           100%[===================&gt;]   1.58M  1.91MB/s    in 0.8s    

2023-09-15 11:59:41 (1.91 MB/s) - ‘train.txt’ saved [1658616/1658616]
</pre></div>
</div>
</div>
</div>
<p>If you’re wondering why there’s a <code class="docutils literal notranslate"><span class="pre">!</span></code> character in the preceding shell command, that’s because we’re running the commands in a Jupyter notebook. Simply remove the prefix if you want to download and unzip the dataset within a terminal. Now, if we peek at the first row of the <em>train.txt</em> file:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>head<span class="w"> </span>-n<span class="w"> </span><span class="m">1</span><span class="w"> </span>train.txt
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>i didnt feel humiliated;sadness
</pre></div>
</div>
</div>
</div>
<p>we can see that here are no column headers and each tweet and emotion are separated by a semicolon. Nevertheless, this is quite similar to a CSV file, so we can load the dataset locally by using the <code class="docutils literal notranslate"><span class="pre">csv</span></code> script and pointing the <code class="docutils literal notranslate"><span class="pre">data_files</span></code> argument to the <em>train.txt</em> file:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="n">emotions_local</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">(</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span> <span class="n">data_files</span><span class="o">=</span><span class="s2">&quot;train.txt&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;;&quot;</span><span class="p">,</span> 
                              <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Downloading data files: 100%|██████████| 1/1 [00:00&lt;00:00, 6921.29it/s]
Extracting data files: 100%|██████████| 1/1 [00:00&lt;00:00, 893.17it/s]
Generating train split: 16000 examples [00:00, 552627.43 examples/s]
</pre></div>
</div>
</div>
</div>
<p>Here we’ve also specified the type of delimiter and the names of the columns. An even simpler approach is to just point the <code class="docutils literal notranslate"><span class="pre">data_files</span></code> argument to the URL itself:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="n">dataset_url</span> <span class="o">=</span> <span class="s2">&quot;https://huggingface.co/datasets/transformersbook/emotion-train-split/raw/main/train.txt&quot;</span>
<span class="n">emotions_remote</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">(</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span> <span class="n">data_files</span><span class="o">=</span><span class="n">dataset_url</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;;&quot;</span><span class="p">,</span> 
                               <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Downloading data: 100%|██████████| 1.66M/1.66M [00:00&lt;00:00, 9.65MB/s]
Downloading data files: 100%|██████████| 1/1 [00:00&lt;00:00,  1.52it/s]
Extracting data files: 100%|██████████| 1/1 [00:00&lt;00:00, 866.59it/s]
Generating train split: 16000 examples [00:00, 560937.37 examples/s]
</pre></div>
</div>
</div>
</div>
<p>which will automatically download and cache the dataset for you. As you can see, the <code class="docutils literal notranslate"><span class="pre">load_dataset()</span></code> function is very versatile. We recommend checking out the image:images/logo.png[hf,13,13] Datasets <a class="reference external" href="https://huggingface.co/docs/datasets/loading.html">documentation</a> to get a complete overview.</p>
</section>
<section id="end-sidebar">
<h3>End sidebar<a class="headerlink" href="#end-sidebar" title="Permalink to this heading">#</a></h3>
</section>
<section id="from-datasets-to-dataframes">
<h3>From Datasets to DataFrames<a class="headerlink" href="#from-datasets-to-dataframes" title="Permalink to this heading">#</a></h3>
<p>Although image:images/logo.png[hf,13,13] Datasets provides a lot of low-level functionality to slice and dice our data, it is often convenient to convert a <code class="docutils literal notranslate"><span class="pre">Dataset</span></code> object to a Pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> so we can access high-level APIs for data visualization. To enable the conversion, image:images/logo.png[hf,13,13] Datasets provides a <code class="docutils literal notranslate"><span class="pre">set_format()</span></code> method that allows us to change the <em>output format</em> of the <code class="docutils literal notranslate"><span class="pre">Dataset</span></code>. Note that this does not change the underlying <em>data format</em> (which is an Arrow table), and you can switch to another format later if needed:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">emotions</span><span class="o">.</span><span class="n">set_format</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;pandas&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">emotions</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">][:]</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>text</th>
      <th>label</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>i didnt feel humiliated</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>i can go from feeling so hopeless to so damned...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>im grabbing a minute to post i feel greedy wrong</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>i am ever feeling nostalgic about the fireplac...</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td>i am feeling grouchy</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>As you can see, the column headers have been preserved and the first few rows match our previous views of the data. However, the labels are represented as integers, so let’s use the <code class="docutils literal notranslate"><span class="pre">int2str()</span></code> method of the <code class="docutils literal notranslate"><span class="pre">label</span></code> feature to create a new column in our <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with the corresponding label names:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">label_int2str</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">emotions</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">int2str</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

<span class="n">df</span><span class="p">[</span><span class="s2">&quot;label_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">label_int2str</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>text</th>
      <th>label</th>
      <th>label_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>i didnt feel humiliated</td>
      <td>0</td>
      <td>sadness</td>
    </tr>
    <tr>
      <th>1</th>
      <td>i can go from feeling so hopeless to so damned...</td>
      <td>0</td>
      <td>sadness</td>
    </tr>
    <tr>
      <th>2</th>
      <td>im grabbing a minute to post i feel greedy wrong</td>
      <td>3</td>
      <td>anger</td>
    </tr>
    <tr>
      <th>3</th>
      <td>i am ever feeling nostalgic about the fireplac...</td>
      <td>2</td>
      <td>love</td>
    </tr>
    <tr>
      <th>4</th>
      <td>i am feeling grouchy</td>
      <td>3</td>
      <td>anger</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Before diving into building a classifier, let’s take a closer look at the dataset. As Andrej Karpathy notes in his famous blog post <a class="reference external" href="https://karpathy.github.io/2019/04/25/recipe">“A Recipe for Training Neural Networks”</a>, becoming “one with the data” is an essential step for training great models!</p>
</section>
<section id="looking-at-the-class-distribution">
<h3>Looking at the Class Distribution<a class="headerlink" href="#looking-at-the-class-distribution" title="Permalink to this heading">#</a></h3>
<p>Whenever you are working on text classification problems, it is a good idea to examine the distribution of examples across the classes. A dataset with a skewed class distribution might require a different treatment in terms of the training loss and evaluation metrics than a balanced one.</p>
<p>With Pandas and Matplotlib, we can quickly visualize the class distribution as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">df</span><span class="p">[</span><span class="s2">&quot;label_name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">barh</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency of Classes&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c9e75b64c1ef8e378431d08e24db3ffcabb1d3f365903651b9d8f23c835797e2.png" src="_images/c9e75b64c1ef8e378431d08e24db3ffcabb1d3f365903651b9d8f23c835797e2.png" />
</div>
</div>
<p>In this case, we can see that the dataset is heavily imbalanced; the <code class="docutils literal notranslate"><span class="pre">joy</span></code> and <code class="docutils literal notranslate"><span class="pre">sadness</span></code> classes appear frequently, whereas <code class="docutils literal notranslate"><span class="pre">love</span></code> and <code class="docutils literal notranslate"><span class="pre">surprise</span></code> are about 5–10 times rarer. There are several ways to deal with imbalanced data, including:</p>
<ul class="simple">
<li><p>Randomly oversample the minority class.</p></li>
<li><p>Randomly undersample the majority class.</p></li>
<li><p>Gather more labeled data from the underrepresented classes.</p></li>
</ul>
<p>To keep things simple in this chapter, we’ll work with the raw, unbalanced class frequencies. If you want to learn more about these sampling techniques, we recommend checking out the <a class="reference external" href="https://imbalanced-learn.org/stable/">Imbalanced-learn library</a>. Just make sure that you don’t apply sampling methods <em>before</em> creating your train/test splits, or you’ll get plenty of leakage between them!</p>
<p>Now that we’ve looked at the classes, let’s take a look at the tweets themselves.</p>
</section>
<section id="how-long-are-our-tweets">
<h3>How Long Are Our Tweets?<a class="headerlink" href="#how-long-are-our-tweets" title="Permalink to this heading">#</a></h3>
<p>Transformer models have a maximum input sequence length that is referred to as the <em>maximum context size</em>. For applications using DistilBERT, the maximum context size is 512 tokens, which amounts to a few paragraphs of text. As we’ll see in the next section, a token is an atomic piece of text; for now, we’ll treat a token as a single word. We can get a rough estimate of tweet lengths per emotion by looking at the distribution of words per tweet:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Words Per Tweet&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="s2">&quot;Words Per Tweet&quot;</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="s2">&quot;label_name&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
           <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/89d523f50d65e75cbbfe90340edd06431d94f2441ed74b2cabbf0caf08e563d9.png" src="_images/89d523f50d65e75cbbfe90340edd06431d94f2441ed74b2cabbf0caf08e563d9.png" />
</div>
</div>
<p>From the plot we see that for each emotion, most tweets are around 15 words long and the longest tweets are well below DistilBERT’s maximum context size. Texts that are longer than a model’s context size need to be truncated, which can lead to a loss in performance if the truncated text contains crucial information; in this case, it looks like that won’t be an issue.</p>
<p>Let’s now figure out how we can convert these raw texts into a format suitable for image:images/logo.png[hf,13,13] Transformers! While we’re at it, let’s also reset the output format of our dataset since we don’t need the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> format anymore:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">emotions</span><span class="o">.</span><span class="n">reset_format</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="from-text-to-tokens">
<h2>From Text to Tokens<a class="headerlink" href="#from-text-to-tokens" title="Permalink to this heading">#</a></h2>
<p>Transformer models like DistilBERT cannot receive raw strings as input; instead, they assume the text has been <em>tokenized</em> and <em>encoded</em> as numerical vectors. Tokenization is the step of breaking down a string into the atomic units used in the model. There are several tokenization strategies one can adopt, and the optimal splitting of words into subunits is usually learned from the corpus. Before looking at the tokenizer used for DistilBERT, let’s consider two extreme cases: <em>character</em> and <em>word</em> tokenization.</p>
<section id="character-tokenization">
<h3>Character Tokenization<a class="headerlink" href="#character-tokenization" title="Permalink to this heading">#</a></h3>
<p>The simplest tokenization scheme is to feed each character individually to the model. In Python, <code class="docutils literal notranslate"><span class="pre">str</span></code> objects are really arrays under the hood, which allows us to quickly implement character-level tokenization with just one line of code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Tokenizing text is a core task of NLP.&quot;</span>
<span class="n">tokenized_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tokenized_text</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;T&#39;, &#39;o&#39;, &#39;k&#39;, &#39;e&#39;, &#39;n&#39;, &#39;i&#39;, &#39;z&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;, &#39; &#39;, &#39;t&#39;, &#39;e&#39;, &#39;x&#39;, &#39;t&#39;, &#39; &#39;, &#39;i&#39;, &#39;s&#39;, &#39; &#39;, &#39;a&#39;, &#39; &#39;, &#39;c&#39;, &#39;o&#39;, &#39;r&#39;, &#39;e&#39;, &#39; &#39;, &#39;t&#39;, &#39;a&#39;, &#39;s&#39;, &#39;k&#39;, &#39; &#39;, &#39;o&#39;, &#39;f&#39;, &#39; &#39;, &#39;N&#39;, &#39;L&#39;, &#39;P&#39;, &#39;.&#39;]
</pre></div>
</div>
</div>
</div>
<p>This is a good start, but we’re not done yet. Our model expects each character to be  converted to an integer, a process sometimes called <em>numericalization</em>. One simple way to do this is by encoding each unique token (which are characters in this case) with a unique integer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">token2idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">ch</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tokenized_text</span><span class="p">)))}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">token2idx</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39; &#39;: 0, &#39;.&#39;: 1, &#39;L&#39;: 2, &#39;N&#39;: 3, &#39;P&#39;: 4, &#39;T&#39;: 5, &#39;a&#39;: 6, &#39;c&#39;: 7, &#39;e&#39;: 8, &#39;f&#39;: 9, &#39;g&#39;: 10, &#39;i&#39;: 11, &#39;k&#39;: 12, &#39;n&#39;: 13, &#39;o&#39;: 14, &#39;r&#39;: 15, &#39;s&#39;: 16, &#39;t&#39;: 17, &#39;x&#39;: 18, &#39;z&#39;: 19}
</pre></div>
</div>
</div>
</div>
<p>This gives us a mapping from each character in our vocabulary to a unique integer. We can now use <code class="docutils literal notranslate"><span class="pre">token2idx</span></code> to transform the tokenized text to a list of integers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">input_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">token2idx</span><span class="p">[</span><span class="n">token</span><span class="p">]</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenized_text</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">input_ids</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[5, 14, 12, 8, 13, 11, 19, 11, 13, 10, 0, 17, 8, 18, 17, 0, 11, 16, 0, 6, 0, 7, 14, 15, 8, 0, 17, 6, 16, 12, 0, 14, 9, 0, 3, 2, 4, 1]
</pre></div>
</div>
</div>
</div>
<p>Each token has now been mapped to a unique numerical identifier (hence the name <code class="docutils literal notranslate"><span class="pre">input_ids</span></code>). The last step is to convert <code class="docutils literal notranslate"><span class="pre">input_ids</span></code> to a 2D tensor of one-hot vectors. One-hot vectors are frequently used in machine learning to encode categorical data, which can be either ordinal or nominal. For example, suppose we wanted to encode the names of characters in the <em>Transformers</em> TV series. One way to do this would be to map each name to a unique ID, as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">categorical_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
    <span class="p">{</span><span class="s2">&quot;Name&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Bumblebee&quot;</span><span class="p">,</span> <span class="s2">&quot;Optimus Prime&quot;</span><span class="p">,</span> <span class="s2">&quot;Megatron&quot;</span><span class="p">],</span> <span class="s2">&quot;Label ID&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]})</span>
<span class="n">categorical_df</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Name</th>
      <th>Label ID</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Bumblebee</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Optimus Prime</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Megatron</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>The problem with this approach is that it creates a fictitious ordering between the names, and neural networks are <em>really</em> good at learning these kinds of relationships. So instead, we can create a new column for each category and assign a 1 where the category is true, and a 0 otherwise. In Pandas, this can be implemented with the <code class="docutils literal notranslate"><span class="pre">get_dummies()</span></code> function as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">categorical_df</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Bumblebee</th>
      <th>Megatron</th>
      <th>Optimus Prime</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>True</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>False</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2</th>
      <td>False</td>
      <td>True</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>The rows of this <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> are the one-hot vectors, which have a single “hot” entry with a 1 and 0s everywhere else. Now, looking at our <code class="docutils literal notranslate"><span class="pre">input_ids</span></code>, we have a similar problem: the elements create an ordinal scale. This means that adding or subtracting two IDs is a meaningless operation, since the result is a new ID that represents another random token.</p>
<p>On the other hand, the result of adding two one-hot encodings can easily be interpreted: the two entries that are “hot” indicate that the corresponding tokens co-occur. We can create the one-hot encodings in PyTorch by converting <code class="docutils literal notranslate"><span class="pre">input_ids</span></code> to a tensor and applying the <code class="docutils literal notranslate"><span class="pre">one_hot()</span></code> function as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="n">input_ids</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">input_ids</span><span class="p">)</span>
<span class="n">one_hot_encodings</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">input_ids</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">token2idx</span><span class="p">))</span>
<span class="n">one_hot_encodings</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([38, 20])
</pre></div>
</div>
</div>
</div>
<p>For each of the 38 input tokens we now have a one-hot vector with 20 dimensions, since our vocabulary consists of 20 unique characters.</p>
<blockquote>
<div><p>Warning: It’s important to always set <code class="docutils literal notranslate"><span class="pre">num_classes</span></code> in the <code class="docutils literal notranslate"><span class="pre">one_hot()</span></code> function because otherwise the one-hot vectors may end up being shorter than the length of the vocabulary (and need to be padded with zeros manually). In TensorFlow, the equivalent function is <code class="docutils literal notranslate"><span class="pre">tf.one_hot()</span></code>, where the <code class="docutils literal notranslate"><span class="pre">depth</span></code> argument plays the role of <code class="docutils literal notranslate"><span class="pre">num_classes</span></code>.</p>
</div></blockquote>
<p>By examining the first vector, we can verify that a 1 appears in the location indicated by <code class="docutils literal notranslate"><span class="pre">input_ids[0]</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Token: </span><span class="si">{</span><span class="n">tokenized_text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tensor index: </span><span class="si">{</span><span class="n">input_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;One-hot: </span><span class="si">{</span><span class="n">one_hot_encodings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Token: T
Tensor index: 5
One-hot: tensor([0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
</pre></div>
</div>
</div>
</div>
<p>From our simple example we can see that character-level tokenization ignores any structure in the text and treats the whole string as a stream of characters. Although this helps deal with misspellings and rare words, the main drawback is that linguistic structures such as words need to be <em>learned</em> from the data. This requires significant compute, memory, and data. For this reason, character tokenization is rarely used in practice. Instead, some structure of the text is preserved during the tokenization step. <em>Word tokenization</em> is a straightforward approach to achieve this, so let’s take a look at how it works.</p>
</section>
<section id="word-tokenization">
<h3>Word Tokenization<a class="headerlink" href="#word-tokenization" title="Permalink to this heading">#</a></h3>
<p>Instead of splitting the text into characters, we can split it into words and map each word to an integer. Using words from the outset enables the model to skip the step of learning words from characters, and thereby reduces the complexity of the training process.</p>
<p>One simple class of word tokenizers uses whitespace to tokenize the text. We can do this by applying Python’s <code class="docutils literal notranslate"><span class="pre">split()</span></code> function directly on the raw text (just like we did to measure the tweet lengths):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tokenized_text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tokenized_text</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;Tokenizing&#39;, &#39;text&#39;, &#39;is&#39;, &#39;a&#39;, &#39;core&#39;, &#39;task&#39;, &#39;of&#39;, &#39;NLP.&#39;]
</pre></div>
</div>
</div>
</div>
<p>From here we can take the same steps we took for the character tokenizer to map each word to an ID. However, we can already see one potential problem with this tokenization scheme: punctuation is not accounted for, so <code class="docutils literal notranslate"><span class="pre">NLP.</span></code> is treated as a single token. Given that words can include declinations, conjugations, or misspellings, the size of the vocabulary can easily grow into the millions!</p>
<blockquote>
<div><p>note: Some word tokenizers have extra rules for punctuation. One can also apply stemming or lemmatization, which normalizes words to their stem (e.g., “great”, “greater”, and “greatest” all become “great”), at the expense of losing some information in the text.</p>
</div></blockquote>
<p>Having a large vocabulary is a problem because it requires neural networks to have an enormous number of parameters. To illustrate this, suppose we have 1 million unique words and want to compress the 1-million-dimensional input vectors to 1-thousand-dimensional vectors in the first layer of our neural network. This is a standard step in most NLP architectures, and the resulting weight matrix of this first layer would contain 1 million <span class="math notranslate nohighlight">\(\times\)</span> 1 thousand = 1 billion weights. This is already comparable to the largest GPT-2 model,footnote:[GPT-2 is the successor of GPT, and it captivated the public’s attention with its impressive ability to generate realistic text. We’ll explore GPT-2 in detail in &lt;&lt;chapter_summarization&gt;&gt;.] which has around 1.5 billion parameters in total!</p>
<p>Naturally, we want to avoid being so wasteful with our model parameters since models are expensive to train, and larger models are more difficult to maintain. A common approach is to limit the vocabulary and discard rare words by considering, say, the 100,000 most common words in the corpus. Words that are not part of the vocabulary are classified as “unknown” and mapped to a shared <code class="docutils literal notranslate"><span class="pre">UNK</span></code> token. This means that we lose some potentially important information in the process of word tokenization, since the model has no information about words associated with <code class="docutils literal notranslate"><span class="pre">UNK</span></code>.</p>
<p>Wouldn’t it be nice if there was a compromise between character and word tokenization that preserved all the input information <em>and</em> some of the input structure? There is: <em>subword tokenization</em>.</p>
</section>
<section id="subword-tokenization">
<h3>Subword Tokenization<a class="headerlink" href="#subword-tokenization" title="Permalink to this heading">#</a></h3>
<p>The basic idea behind subword tokenization is to combine the best aspects of character and word tokenization. On the one hand, we want to split rare words into smaller units to allow the model to deal with complex words and misspellings. On the other hand, we want to keep frequent words as unique entities so that we can keep the length of our inputs to a manageable size. The main distinguishing feature of subword tokenization (as well as word tokenization) is that it is <em>learned</em> from the pretraining corpus using a mix of statistical rules and algorithms.</p>
<p>There are several subword tokenization algorithms that are commonly used in NLP, but let’s start with WordPiece,footnote:[M. Schuster and K. Nakajima, “Japanese and Korean Voice Search,” <em>2012 IEEE International Conference on Acoustics, Speech and Signal Processing</em> (2012): 5149–5152, <a class="reference external" href="https://doi.org/10.1109/ICASSP.2012.6289079.">https://doi.org/10.1109/ICASSP.2012.6289079.</a>] which is used by the BERT and DistilBERT tokenizers. The easiest way to understand how WordPiece works is to see it in action. image:images/logo.png[hf,13,13] Transformers provides a convenient <code class="docutils literal notranslate"><span class="pre">AutoTokenizer</span></code> class that allows you to quickly load the tokenizer associated with a pretrained model—we just call its <code class="docutils literal notranslate"><span class="pre">from_pretrained()</span></code> method, providing the ID of a model on the Hub or a local file path. Let’s start by loading the tokenizer for DistilBERT:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># hide_output</span>
<span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">AutoTokenizer</span>

<span class="n">model_ckpt</span> <span class="o">=</span> <span class="s2">&quot;distilbert-base-uncased&quot;</span>
<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">AutoTokenizer</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_ckpt</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">AutoTokenizer</span></code> class belongs to a larger set of <a class="reference external" href="https://huggingface.co/docs/transformers/model_doc/auto">“auto” classes</a> whose job is to automatically retrieve the model’s configuration, pretrained weights, or vocabulary from the name of the checkpoint. This allows you to quickly switch between models, but if you wish to load the specific class manually you can do so as well. For example, we could have loaded the DistilBERT tokenizer as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">DistilBertTokenizer</span>

<span class="n">distilbert_tokenizer</span> <span class="o">=</span> <span class="n">DistilBertTokenizer</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_ckpt</span><span class="p">)</span>
</pre></div>
</div>
<blockquote>
<div><p>note: When you run the <code class="docutils literal notranslate"><span class="pre">AutoTokenizer.from_pretrained()</span></code> method for the first time you will see a progress bar that shows which parameters of the pretrained tokenizer are loaded from the Hugging Face Hub. When you run the code a second time, it will load the tokenizer from the cache, usually located at <em>~/.cache/huggingface/</em>.</p>
</div></blockquote>
<p>Let’s examine how this tokenizer works by feeding it our simple “Tokenizing text is a core task of NLP.” example text:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">encoded_text</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">encoded_text</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;input_ids&#39;: [101, 19204, 6026, 3793, 2003, 1037, 4563, 4708, 1997, 17953, 2361, 1012, 102], &#39;attention_mask&#39;: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}
</pre></div>
</div>
</div>
</div>
<p>Just like we saw with character tokenization, we can see that the words have been mapped to unique integers in the <code class="docutils literal notranslate"><span class="pre">input_ids</span></code> field. We’ll discuss the role of the <code class="docutils literal notranslate"><span class="pre">attention_mask</span></code> field in the next section. Now that we have the <code class="docutils literal notranslate"><span class="pre">input_ids</span></code>, we can convert them back into tokens by using the tokenizer’s <code class="docutils literal notranslate"><span class="pre">convert_ids_to_tokens()</span></code> method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">convert_ids_to_tokens</span><span class="p">(</span><span class="n">encoded_text</span><span class="o">.</span><span class="n">input_ids</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;[CLS]&#39;, &#39;token&#39;, &#39;##izing&#39;, &#39;text&#39;, &#39;is&#39;, &#39;a&#39;, &#39;core&#39;, &#39;task&#39;, &#39;of&#39;, &#39;nl&#39;, &#39;##p&#39;, &#39;.&#39;, &#39;[SEP]&#39;]
</pre></div>
</div>
</div>
</div>
<p>We can observe three things here. First, some special <code class="docutils literal notranslate"><span class="pre">[CLS]</span></code> and <code class="docutils literal notranslate"><span class="pre">[SEP]</span></code> tokens have been added to the start and end of the sequence. These tokens differ from model to model, but their main role is to indicate the start and end of a sequence. Second, the tokens have each been lowercased, which is a feature of this particular checkpoint. Finally, we can see that “tokenizing” and “NLP” have been split into two tokens, which makes sense since they are not common words. The <code class="docutils literal notranslate"><span class="pre">##</span></code> prefix in <code class="docutils literal notranslate"><span class="pre">##izing</span></code> and <code class="docutils literal notranslate"><span class="pre">##p</span></code> means that the preceding string is not whitespace; any token with this prefix should be merged with the previous token when you convert the tokens back to a string. The <code class="docutils literal notranslate"><span class="pre">AutoTokenizer</span></code> class has a <code class="docutils literal notranslate"><span class="pre">convert_tokens_to_string()</span></code> method for doing just that, so let’s apply it to our tokens:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">convert_tokens_to_string</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[CLS] tokenizing text is a core task of nlp. [SEP]
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">AutoTokenizer</span></code> class also has several attributes that provide information about the tokenizer. For example, we can inspect the vocabulary size:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tokenizer</span><span class="o">.</span><span class="n">vocab_size</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>30522
</pre></div>
</div>
</div>
</div>
<p>and the corresponding model’s maximum context size:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tokenizer</span><span class="o">.</span><span class="n">model_max_length</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>512
</pre></div>
</div>
</div>
</div>
<p>Another interesting attribute to know about is the names of the fields that the model expects in its forward pass:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tokenizer</span><span class="o">.</span><span class="n">model_input_names</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;input_ids&#39;, &#39;attention_mask&#39;]
</pre></div>
</div>
</div>
</div>
<p>Now that we have a basic understanding of the tokenization process for a single string, let’s see how we can tokenize the whole dataset!</p>
<blockquote>
<div><p>warning: When using pretrained models, it is <em>really</em> important to make sure that you use the same tokenizer that the model was trained with. From the model’s perspective, switching the tokenizer is like shuffling the vocabulary. If everyone around you started swapping random words like “house” for “cat,” you’d have a hard time understanding what was going on too!</p>
</div></blockquote>
</section>
<section id="tokenizing-the-whole-dataset">
<h3>Tokenizing the Whole Dataset<a class="headerlink" href="#tokenizing-the-whole-dataset" title="Permalink to this heading">#</a></h3>
<p>To tokenize the whole corpus, we’ll use the <code class="docutils literal notranslate"><span class="pre">map()</span></code> method of our <code class="docutils literal notranslate"><span class="pre">DatasetDict</span></code> object. We’ll encounter this method many times throughout this book, as it provides a convenient way to apply a processing function to each element in a dataset. As we’ll soon see, the <code class="docutils literal notranslate"><span class="pre">map()</span></code> method can also be used to create new rows and columns.</p>
<p>To get started, the first thing we need is a processing function to tokenize our examples with:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">truncation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This function applies the tokenizer to a batch of examples; <code class="docutils literal notranslate"><span class="pre">padding=True</span></code> will pad the examples with zeros to the size of the longest one in a batch, and <code class="docutils literal notranslate"><span class="pre">truncation=True</span></code> will truncate the examples to the model’s maximum context size. To see <code class="docutils literal notranslate"><span class="pre">tokenize()</span></code> in action, let’s pass a batch of two examples from the training set:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">tokenize</span><span class="p">(</span><span class="n">emotions</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">][:</span><span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;input_ids&#39;: [[101, 1045, 2134, 2102, 2514, 26608, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [101, 1045, 2064, 2175, 2013, 3110, 2061, 20625, 2000, 2061, 9636, 17772, 2074, 2013, 2108, 2105, 2619, 2040, 14977, 1998, 2003, 8300, 102]], &#39;attention_mask&#39;: [[1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}
</pre></div>
</div>
</div>
</div>
<p>Here we can see the result of padding: the first element of <code class="docutils literal notranslate"><span class="pre">input_ids</span></code> is shorter than the second, so zeros have been added to that element to make them the same length. These zeros have a corresponding <code class="docutils literal notranslate"><span class="pre">[PAD]</span></code> token in the vocabulary, and the set of special tokens also includes the <code class="docutils literal notranslate"><span class="pre">[CLS]</span></code> and <code class="docutils literal notranslate"><span class="pre">[SEP]</span></code> tokens that we encountered earlier:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_input</span>
<span class="n">tokens2ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">all_special_tokens</span><span class="p">,</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">all_special_ids</span><span class="p">))</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tokens2ids</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Special Token&quot;</span><span class="p">,</span> <span class="s2">&quot;Special Token ID&quot;</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Special Token</th>
      <td>[PAD]</td>
      <td>[UNK]</td>
      <td>[CLS]</td>
      <td>[SEP]</td>
      <td>[MASK]</td>
    </tr>
    <tr>
      <th>Special Token ID</th>
      <td>0</td>
      <td>100</td>
      <td>101</td>
      <td>102</td>
      <td>103</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Also note that in addition to returning the encoded tweets as <code class="docutils literal notranslate"><span class="pre">input_ids</span></code>, the tokenizer returns a list of <code class="docutils literal notranslate"><span class="pre">attention_mask</span></code> arrays. This is because we do not want the model to get confused by the additional padding tokens: the attention mask allows the model to ignore the padded parts of the input. &lt;<attention-mask>&gt; provides a visual explanation of how the input IDs and attention masks are padded.</p>
<img alt="attention-mask" src="images/chapter02_attention-mask.png" />
<p>Once we’ve defined a processing function, we can apply it across all the splits in the corpus in a single line of code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># hide_output</span>
<span class="n">emotions_encoded</span> <span class="o">=</span> <span class="n">emotions</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">tokenize</span><span class="p">,</span> <span class="n">batched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Map: 100%|██████████| 16000/16000 [00:00&lt;00:00, 32343.96 examples/s]
Map: 100%|██████████| 2000/2000 [00:00&lt;00:00, 80316.03 examples/s]
Map: 100%|██████████| 2000/2000 [00:00&lt;00:00, 78553.11 examples/s]
</pre></div>
</div>
</div>
</div>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">map()</span></code> method operates individually on every example in the corpus, so setting <code class="docutils literal notranslate"><span class="pre">batched=True</span></code> will encode the tweets in batches. Because we’ve set <code class="docutils literal notranslate"><span class="pre">batch_size=None</span></code>, our <code class="docutils literal notranslate"><span class="pre">tokenize()</span></code> function will be applied on the full dataset as a single batch. This ensures that the input tensors and attention masks have the same shape globally, and we can see that this operation has added new <code class="docutils literal notranslate"><span class="pre">input_ids</span></code> and <code class="docutils literal notranslate"><span class="pre">attention_mask</span></code> columns to the dataset:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">column_names</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;text&#39;, &#39;label&#39;, &#39;input_ids&#39;, &#39;attention_mask&#39;]
</pre></div>
</div>
</div>
</div>
<blockquote>
<div><p>Note: In later chapters, we’ll see how <em>data collators</em> can be used to dynamically pad the tensors in each batch. Padding globally will come in handy in the next section, where we extract a feature matrix from the whole corpus.</p>
</div></blockquote>
</section>
</section>
<section id="training-a-text-classifier">
<h2>Training a Text Classifier<a class="headerlink" href="#training-a-text-classifier" title="Permalink to this heading">#</a></h2>
<p>As discussed in &lt;&lt;chapter_introduction&gt;&gt;, models like DistilBERT are pretrained to predict masked words in a sequence of text. However, we can’t use these language models directly for text classification; we need to modify them slightly. To understand what modifications are necessary, let’s take a look at the architecture of an encoder-based model like DistilBERT, which is depicted in &lt;<encoder-classifier>&gt;.</p>
<img alt="encoder-classifier" src="images/chapter02_encoder-classifier.png" />
<p>First, the text is tokenized and represented as one-hot vectors called <em>token encodings</em>. The size of the tokenizer vocabulary determines the dimension of the token encodings, and it usually consists of 20k–200k unique tokens. Next, these token encodings are converted to <em>token embeddings</em>, which are vectors living in a lower-dimensional space. The token embeddings are then passed through the encoder block layers to yield a <em>hidden state</em> for each input token. For the pretraining objective of language modeling,⁠footnote:[In the case of DistilBERT, it’s guessing the masked tokens.] each hidden state is fed to a layer that predicts the masked input tokens. For the classification task, we replace the language modeling layer with a classification layer.</p>
<blockquote>
<div><p>note: In practice, PyTorch skips the step of creating one-hot vectors for token encodings because multiplying a matrix with a one-hot vector is the same as selecting a column from the matrix. This can be done directly by getting the column with the token ID from the matrix. We’ll see this in &lt;&lt;chapter_anatomy&gt;&gt; when we use the <code class="docutils literal notranslate"><span class="pre">nn.Embedding</span></code> class.</p>
</div></blockquote>
<p>We have two options to train such a model on our Twitter dataset:</p>
<ul class="simple">
<li><p><em>Feature extraction</em>:: We use the hidden states as features and just train a classifier on them, without modifying the pretrained model.</p></li>
<li><p><em>Fine-tuning</em>:: We train the whole model end-to-end, which also updates the parameters of the pretrained model.</p></li>
</ul>
<p>In the following sections we explore both options for DistilBERT and examine their trade-offs.</p>
<section id="transformers-as-feature-extractors">
<h3>Transformers as Feature Extractors<a class="headerlink" href="#transformers-as-feature-extractors" title="Permalink to this heading">#</a></h3>
<p>Using a transformer as a feature extractor is fairly simple. As shown in &lt;<encoder-features>&gt;, we freeze the body’s weights during training and use the hidden states as features for the classifier. The advantage of this approach is that we can quickly train a small or shallow model. Such a model could be a neural classification layer or a method that does not rely on gradients, such as a random forest. This method is especially convenient if GPUs are unavailable, since the hidden states only need to be precomputed once.</p>
<img alt="encoder-features" src="images/chapter02_encoder-feature-based.png" />
<section id="using-pretrained-models">
<h4>Using pretrained models<a class="headerlink" href="#using-pretrained-models" title="Permalink to this heading">#</a></h4>
<p>We will use another convenient auto class from image:images/logo.png[hf,13,13] Transformers called <code class="docutils literal notranslate"><span class="pre">AutoModel</span></code>. Similar to the <code class="docutils literal notranslate"><span class="pre">AutoTokenizer</span></code> class, <code class="docutils literal notranslate"><span class="pre">AutoModel</span></code> has a <code class="docutils literal notranslate"><span class="pre">from_pretrained()</span></code> method to load the weights of a pretrained model. Let’s use this method to load the DistilBERT checkpoint:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># hide_output</span>
<span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">AutoModel</span>

<span class="n">model_ckpt</span> <span class="o">=</span> <span class="s2">&quot;distilbert-base-uncased&quot;</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">AutoModel</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_ckpt</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here we’ve used PyTorch to check whether a GPU is available or not, and then chained the PyTorch <code class="docutils literal notranslate"><span class="pre">nn.Module.to()</span></code> method to the model loader. This ensures that the model will run on the GPU if we have one. If not, the model will run on the CPU, which can be considerably slower.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AutoModel</span></code> class converts the token encodings to embeddings, and then feeds them through the encoder stack to return the hidden states. Let’s take a look at how we can extract these states from our corpus.</p>
</section>
</section>
<section id="sidebar-interoperability-between-frameworks">
<h3>Sidebar: Interoperability Between Frameworks<a class="headerlink" href="#sidebar-interoperability-between-frameworks" title="Permalink to this heading">#</a></h3>
<p>Although the code in this book is mostly written in PyTorch, image:images/logo.png[hf,13,13] Transformers provides tight interoperability with TensorFlow and JAX. This means that you only need to change a few lines of code to load a pretrained model in your favorite deep learning framework! For example, we can load DistilBERT in TensorFlow by using the <code class="docutils literal notranslate"><span class="pre">TFAutoModel</span></code> class as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">TFAutoModel</span>

<span class="n">tf_model</span> <span class="o">=</span> <span class="n">TFAutoModel</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_ckpt</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2021-10-23 17:03:51.654626: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library &#39;libcudnn.so.8&#39;; dlerror: libcudnn.so.8: cannot open shared object file: No such file or directory
2021-10-23 17:03:51.654664: W tensorflow/core/common_runtime/gpu/gpu_device.cc:1835] Cannot dlopen some GPU libraries. Please make sure the missing libraries mentioned above are installed properly if you would like to use GPU. Follow the guide at https://www.tensorflow.org/install/gpu for how to download and setup the required libraries for your platform.
Skipping registering GPU devices...
2021-10-23 17:03:51.655491: I tensorflow/core/platform/cpu_feature_guard.cc:142] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX2 AVX512F FMA
To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.
2021-10-23 17:03:51.680031: W tensorflow/python/util/util.cc:348] Sets are not currently considered sequences, but this may change in the future, so consider avoiding using them.
</pre></div>
</div>
</div>
</div>
<p>This interoperability is especially useful when a model is only released in one framework, but you’d like to use it in another. For example, the <a class="reference external" href="https://huggingface.co/xlm-roberta-base">XLM-RoBERTa model</a> that we’ll encounter in &lt;&lt;chapter_ner&gt;&gt; only has PyTorch weights, so if you try to load it in TensorFlow as we did before:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tf_xlmr</span> <span class="o">=</span> <span class="n">TFAutoModel</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="s2">&quot;xlm-roberta-base&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>you’ll get an error. In these cases, you can specify a <code class="docutils literal notranslate"><span class="pre">from_pt=True</span></code> argument to the <code class="docutils literal notranslate"><span class="pre">TfAutoModel.from_pretrained()</span></code> function, and the library will automatically download and convert the PyTorch weights for you:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tf_xlmr</span> <span class="o">=</span> <span class="n">TFAutoModel</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="s2">&quot;xlm-roberta-base&quot;</span><span class="p">,</span> <span class="n">from_pt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As you can see, it is very simple to switch between frameworks in image:images/logo.png[hf,13,13] Transformers! In most cases, you can just add a “TF” prefix to the classes and you’ll get the equivalent TensorFlow 2.0 classes. When we use the <code class="docutils literal notranslate"><span class="pre">&quot;pt&quot;</span></code> string (e.g., in the following section), which is short for PyTorch, just replace it with “<code class="docutils literal notranslate"><span class="pre">tf&quot;</span></code>, which is short for TensorFlow.</p>
</section>
<section id="id1">
<h3>End sidebar<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<section id="extracting-the-last-hidden-states">
<h4>Extracting the last hidden states<a class="headerlink" href="#extracting-the-last-hidden-states" title="Permalink to this heading">#</a></h4>
<p>To warm up, let’s retrieve the last hidden states for a single string. The first thing we need to do is encode the string and convert the tokens to PyTorch tensors. This can be done by providing the <code class="docutils literal notranslate"><span class="pre">return_tensors=&quot;pt&quot;</span></code> argument to the tokenizer as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;this is a test&quot;</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">return_tensors</span><span class="o">=</span><span class="s2">&quot;pt&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input tensor shape: </span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;input_ids&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Input tensor shape: torch.Size([1, 6])
</pre></div>
</div>
</div>
</div>
<p>As we can see, the resulting tensor has the shape <code class="docutils literal notranslate"><span class="pre">[batch_size,</span> <span class="pre">n_tokens]</span></code>. Now that we have the encodings as a tensor, the final step is to place them on the same device as the model and pass the inputs as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">inputs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>BaseModelOutput(last_hidden_state=tensor([[[-0.1565, -0.1862,  0.0528,  ..., -0.1188,  0.0662,  0.5470],
         [-0.3575, -0.6484, -0.0618,  ..., -0.3040,  0.3508,  0.5221],
         [-0.2772, -0.4459,  0.1818,  ..., -0.0948, -0.0076,  0.9958],
         [-0.2841, -0.3917,  0.3753,  ..., -0.2151, -0.1173,  1.0526],
         [ 0.2661, -0.5094, -0.3180,  ..., -0.4203,  0.0144, -0.2149],
         [ 0.9441,  0.0112, -0.4714,  ...,  0.1439, -0.7288, -0.1619]]],
       device=&#39;cuda:0&#39;), hidden_states=None, attentions=None)
</pre></div>
</div>
</div>
</div>
<p>Here we’ve used the <code class="docutils literal notranslate"><span class="pre">torch.no_grad()</span></code> context manager to disable the automatic calculation of the gradient. This is useful for inference since it reduces the memory footprint of the computations. Depending on the model configuration, the output can contain several objects, such as the hidden states, losses, or attentions, arranged in a class similar to a <code class="docutils literal notranslate"><span class="pre">namedtuple</span></code> in Python. In our example, the model output is an instance of <code class="docutils literal notranslate"><span class="pre">BaseModelOutput</span></code>, and we can simply access its attributes by name. The current model returns only one attribute, which is the last hidden state, so let’s examine its shape:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">outputs</span><span class="o">.</span><span class="n">last_hidden_state</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 6, 768])
</pre></div>
</div>
</div>
</div>
<p>Looking at the hidden state tensor, we see that it has the shape <code class="docutils literal notranslate"><span class="pre">[batch_size,</span> <span class="pre">n_tokens,</span> <span class="pre">hidden_dim]</span></code>. In other words, a 768-dimensional vector is returned for each of the 6 input tokens. For classification tasks, it is common practice to just use the hidden state associated with the <code class="docutils literal notranslate"><span class="pre">[CLS]</span></code> token as the input feature. Since this token appears at the start of each sequence, we can extract it by simply indexing into <code class="docutils literal notranslate"><span class="pre">outputs.last_hidden_state</span></code> as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">outputs</span><span class="o">.</span><span class="n">last_hidden_state</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 768])
</pre></div>
</div>
</div>
</div>
<p>Now that we know how to get the last hidden state for a single string, let’s do the same thing for the whole dataset by creating a new <code class="docutils literal notranslate"><span class="pre">hidden_state</span></code> column that stores all these vectors. As we did with the tokenizer, we’ll use the <code class="docutils literal notranslate"><span class="pre">map()</span></code> method of <code class="docutils literal notranslate"><span class="pre">DatasetDict</span></code> to extract all the hidden states in one go. The first thing we need to do is wrap the previous steps in a processing function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extract_hidden_states</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
    <span class="c1"># Place model inputs on the GPU</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">batch</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
              <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">model_input_names</span><span class="p">}</span>
    <span class="c1"># Extract last hidden states</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">last_hidden_state</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">inputs</span><span class="p">)</span><span class="o">.</span><span class="n">last_hidden_state</span>
    <span class="c1"># Return vector for [CLS] token</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;hidden_state&quot;</span><span class="p">:</span> <span class="n">last_hidden_state</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()}</span>
</pre></div>
</div>
</div>
</div>
<p>The only difference between this function and our previous logic is the final step where we place the final hidden state back on the CPU as a NumPy array. The <code class="docutils literal notranslate"><span class="pre">map()</span></code> method requires the processing function to return Python or NumPy objects when we’re using batched inputs.</p>
<p>Since our model expects tensors as inputs, the next thing to do is convert the <code class="docutils literal notranslate"><span class="pre">input_ids</span></code> and <code class="docutils literal notranslate"><span class="pre">attention_mask</span></code> columns to the <code class="docutils literal notranslate"><span class="pre">&quot;torch&quot;</span></code> format, as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">emotions_encoded</span><span class="o">.</span><span class="n">set_format</span><span class="p">(</span><span class="s2">&quot;torch&quot;</span><span class="p">,</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">,</span> <span class="s2">&quot;attention_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">emotions_encoded</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DatasetDict({
    train: Dataset({
        features: [&#39;text&#39;, &#39;label&#39;, &#39;input_ids&#39;, &#39;attention_mask&#39;],
        num_rows: 16000
    })
    validation: Dataset({
        features: [&#39;text&#39;, &#39;label&#39;, &#39;input_ids&#39;, &#39;attention_mask&#39;],
        num_rows: 2000
    })
    test: Dataset({
        features: [&#39;text&#39;, &#39;label&#39;, &#39;input_ids&#39;, &#39;attention_mask&#39;],
        num_rows: 2000
    })
})
</pre></div>
</div>
</div>
</div>
<p>We can then go ahead and extract the hidden states across all splits in one go:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="n">emotions_hidden</span> <span class="o">=</span> <span class="n">emotions_encoded</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">extract_hidden_states</span><span class="p">,</span> <span class="n">batched</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Map: 100%|██████████| 16000/16000 [00:07&lt;00:00, 2004.96 examples/s]
Map: 100%|██████████| 2000/2000 [00:00&lt;00:00, 2530.06 examples/s]
Map: 100%|██████████| 2000/2000 [00:00&lt;00:00, 2651.57 examples/s]
</pre></div>
</div>
</div>
</div>
<p>Note that we did not set <code class="docutils literal notranslate"><span class="pre">batch_size=None</span></code> in this case, so the default <code class="docutils literal notranslate"><span class="pre">batch_size=1000</span></code> is used instead. As expected, applying the +extract_​hid⁠den_​states()+ function has added a new <code class="docutils literal notranslate"><span class="pre">hidden_state</span></code> column to our dataset:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">emotions_hidden</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">column_names</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;attention_mask&#39;, &#39;hidden_state&#39;, &#39;input_ids&#39;, &#39;label&#39;, &#39;text&#39;]
</pre></div>
</div>
</div>
</div>
<p>Now that we have the hidden states associated with each tweet, the next step is to train a classifier on them. To do that, we’ll need a feature matrix - let’s take a look.</p>
</section>
<section id="creating-a-feature-matrix">
<h4>Creating a feature matrix<a class="headerlink" href="#creating-a-feature-matrix" title="Permalink to this heading">#</a></h4>
<p>The preprocessed dataset now contains all the information we need to train a classifier on it. We will use the hidden states as input features and the labels as targets. We can easily create the corresponding arrays in the well-known Scikit-Learn format as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">emotions_hidden</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">][</span><span class="s2">&quot;hidden_state&quot;</span><span class="p">])</span>
<span class="n">X_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">emotions_hidden</span><span class="p">[</span><span class="s2">&quot;validation&quot;</span><span class="p">][</span><span class="s2">&quot;hidden_state&quot;</span><span class="p">])</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">emotions_hidden</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">][</span><span class="s2">&quot;label&quot;</span><span class="p">])</span>
<span class="n">y_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">emotions_hidden</span><span class="p">[</span><span class="s2">&quot;validation&quot;</span><span class="p">][</span><span class="s2">&quot;label&quot;</span><span class="p">])</span>
<span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">X_valid</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>((16000, 768), (2000, 768))
</pre></div>
</div>
</div>
</div>
<p>Before we train a model on the hidden states, it’s good practice to perform a sanity check to ensure that they provide a useful representation of the emotions we want to classify. In the next section, we’ll see how visualizing the features provides a fast way to achieve this.</p>
</section>
<section id="visualizing-the-training-set">
<h4>Visualizing the training set<a class="headerlink" href="#visualizing-the-training-set" title="Permalink to this heading">#</a></h4>
<p>Since visualizing the hidden states in 768 dimensions is tricky to say the least, we’ll use the powerful UMAPfootnote:[L. McInnes, J. Healy, and J. Melville, <a class="reference external" href="https://arxiv.org/abs/1802.03426">“UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction”</a>, (2018).] algorithm to project the vectors down to 2D.  Since UMAP works best when the features are scaled to lie in the [0,1] interval, we’ll first apply a <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> and then use the UMAP implementation from the <code class="docutils literal notranslate"><span class="pre">umap-learn</span></code> library to reduce the hidden states:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">umap</span> <span class="kn">import</span> <span class="n">UMAP</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>

<span class="c1"># Scale features to [0,1] range</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="c1"># Initialize and fit UMAP</span>
<span class="n">mapper</span> <span class="o">=</span> <span class="n">UMAP</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;cosine&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)</span>
<span class="c1"># Create a DataFrame of 2D embeddings</span>
<span class="n">df_emb</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">])</span>
<span class="n">df_emb</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train</span>
<span class="n">df_emb</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>X</th>
      <th>Y</th>
      <th>label</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>4.358075</td>
      <td>6.140816</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-3.134567</td>
      <td>5.329446</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5.152230</td>
      <td>2.732643</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-2.519018</td>
      <td>3.067250</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-3.364520</td>
      <td>3.356613</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>The result is an array with the same number of training samples, but with only 2 features instead of the 768 we started with! Let’s investigate the compressed data a little bit further and plot the density of points for each category separately:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">cmaps</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Greys&quot;</span><span class="p">,</span> <span class="s2">&quot;Blues&quot;</span><span class="p">,</span> <span class="s2">&quot;Oranges&quot;</span><span class="p">,</span> <span class="s2">&quot;Reds&quot;</span><span class="p">,</span> <span class="s2">&quot;Purples&quot;</span><span class="p">,</span> <span class="s2">&quot;Greens&quot;</span><span class="p">]</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">emotions</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">names</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">cmap</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">cmaps</span><span class="p">)):</span>
    <span class="n">df_emb_sub</span> <span class="o">=</span> <span class="n">df_emb</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;label == </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hexbin</span><span class="p">(</span><span class="n">df_emb_sub</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">],</span> <span class="n">df_emb_sub</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                   <span class="n">gridsize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([]),</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/4aa49e1783b72fe3125f1e3df9f86df83b20df16b132f818f4bfdc6fd703145b.svg" src="_images/4aa49e1783b72fe3125f1e3df9f86df83b20df16b132f818f4bfdc6fd703145b.svg" /></div>
</div>
<blockquote>
<div><p>note: These are only projections onto a lower-dimensional space. Just because some categories overlap does not mean that they are not separable in the original space. Conversely, if they are separable in the projected space they will be separable in the original space.</p>
</div></blockquote>
<p>From this plot we can see some clear patterns: the negative feelings such as <code class="docutils literal notranslate"><span class="pre">sadness</span></code>, <code class="docutils literal notranslate"><span class="pre">anger</span></code>, and <code class="docutils literal notranslate"><span class="pre">fear</span></code> all occupy similar regions with slightly varying distributions. On the other hand, <code class="docutils literal notranslate"><span class="pre">joy</span></code> and <code class="docutils literal notranslate"><span class="pre">love</span></code> are well separated from the negative emotions and also share a similar space. Finally, <code class="docutils literal notranslate"><span class="pre">surprise</span></code> is scattered all over the place. Although we may have hoped for some separation, this is in no way guaranteed since the model was not trained to know the difference between these emotions. It only learned them implicitly by guessing the masked words in texts.</p>
<p>Now that we’ve gained some insight into the features of our dataset, let’s finally train a model on it!</p>
</section>
<section id="training-a-simple-classifier">
<h4>Training a simple classifier<a class="headerlink" href="#training-a-simple-classifier" title="Permalink to this heading">#</a></h4>
<p>We’ve seen that the hidden states are somewhat different between the emotions, although for several of them there is no obvious boundary. Let’s use these hidden states to train a logistic regression model with Scikit-Learn. Training such a simple model is fast and does not require a GPU:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="c1"># We increase `max_iter` to guarantee convergence </span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>

<span class="n">lr_clf</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">lr_clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/home/lewis/miniconda3/envs/book/lib/python3.7/site-packages/sklearn/linear_model/_logistic.py:818: ConvergenceWarning: lbfgs failed to converge (status=1):
STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.

Increase the number of iterations (max_iter) or scale the data as shown in:
    https://scikit-learn.org/stable/modules/preprocessing.html
Please also refer to the documentation for alternative solver options:
    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression
  extra_warning_msg=_LOGISTIC_SOLVER_CONVERGENCE_MSG,
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>LogisticRegression()
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lr_clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_valid</span><span class="p">,</span> <span class="n">y_valid</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.6085
</pre></div>
</div>
</div>
</div>
<p>Looking at the accuracy, it might appear that our model is just a bit better than random—but since we are dealing with an unbalanced multiclass dataset, it’s actually significantly better. We can examine whether our model is any good by comparing it against a simple baseline. In Scikit-Learn there is a <code class="docutils literal notranslate"><span class="pre">DummyClassifier</span></code> that can be used to build a classifier with simple heuristics such as always choosing the majority class or always drawing a random class. In this case the best-performing heuristic is to always choose the most frequent class, which yields an accuracy of about 35%:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.dummy</span> <span class="kn">import</span> <span class="n">DummyClassifier</span>

<span class="n">dummy_clf</span> <span class="o">=</span> <span class="n">DummyClassifier</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;most_frequent&quot;</span><span class="p">)</span>
<span class="n">dummy_clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">dummy_clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_valid</span><span class="p">,</span> <span class="n">y_valid</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.352
</pre></div>
</div>
</div>
</div>
<p>So, our simple classifier with DistilBERT embeddings is significantly better than our baseline. We can further investigate the performance of the model by looking at the confusion matrix of the classifier, which tells us the relationship between the true and predicted labels:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">ConfusionMatrixDisplay</span><span class="p">,</span> <span class="n">confusion_matrix</span>

<span class="k">def</span> <span class="nf">plot_confusion_matrix</span><span class="p">(</span><span class="n">y_preds</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_preds</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">disp</span> <span class="o">=</span> <span class="n">ConfusionMatrixDisplay</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="o">=</span><span class="n">cm</span><span class="p">,</span> <span class="n">display_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">disp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;Blues&quot;</span><span class="p">,</span> <span class="n">values_format</span><span class="o">=</span><span class="s2">&quot;.2f&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Normalized confusion matrix&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="n">y_preds</span> <span class="o">=</span> <span class="n">lr_clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_valid</span><span class="p">)</span>
<span class="n">plot_confusion_matrix</span><span class="p">(</span><span class="n">y_preds</span><span class="p">,</span> <span class="n">y_valid</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/21107e48b6cc19d50af32c9a439fc1e8ac8626fe7396794bf26f114e0340582c.svg" src="_images/21107e48b6cc19d50af32c9a439fc1e8ac8626fe7396794bf26f114e0340582c.svg" /></div>
</div>
<p>We can see that <code class="docutils literal notranslate"><span class="pre">anger</span></code> and <code class="docutils literal notranslate"><span class="pre">fear</span></code> are most often confused with <code class="docutils literal notranslate"><span class="pre">sadness</span></code>, which agrees with the observation we made when visualizing the embeddings. Also, <code class="docutils literal notranslate"><span class="pre">love</span></code> and <code class="docutils literal notranslate"><span class="pre">surprise</span></code> are frequently mistaken for <code class="docutils literal notranslate"><span class="pre">joy</span></code>.</p>
<p>In the next section we will explore the fine-tuning approach, which leads to superior classification performance. It is, however, important to note that doing this requires more computational resources, such as GPUs, that might not be available in your organization. In cases like these, a feature-based approach can be a good compromise between doing traditional machine learning and deep learning.</p>
</section>
</section>
<section id="fine-tuning-transformers">
<h3>Fine-Tuning Transformers<a class="headerlink" href="#fine-tuning-transformers" title="Permalink to this heading">#</a></h3>
<p>Let’s now explore what it takes to fine-tune a transformer end-to-end. With the fine-tuning approach we do not use the hidden states as fixed features, but instead train them as shown in &lt;<encoder-tuning>&gt;. This requires the classification head to be differentiable, which is why this method usually uses a neural network for classification.</p>
<img alt="encoder-tuning" src="images/chapter02_encoder-fine-tuning.png" />
<p>Training the hidden states that serve as inputs to the classification model will help us avoid the problem of working with data that may not be well suited for the classification task. Instead, the initial hidden states adapt during training to decrease the model loss and thus increase its performance.</p>
<p>We’ll be using the <code class="docutils literal notranslate"><span class="pre">Trainer</span></code> API from image:images/logo.png[hf,13,13] Transformers to simplify the training loop. Let’s look at the ingredients we need to set one up!</p>
<section id="loading-a-pretrained-model">
<h4>Loading a pretrained model<a class="headerlink" href="#loading-a-pretrained-model" title="Permalink to this heading">#</a></h4>
<p>The first thing we need is a pretrained DistilBERT model like the one we used in the feature-based approach. The only slight modification is that we use the <code class="docutils literal notranslate"><span class="pre">AutoModelForSequenceClassification</span></code> model instead of <code class="docutils literal notranslate"><span class="pre">AutoModel</span></code>. The difference is that the <code class="docutils literal notranslate"><span class="pre">AutoModelForSequenceClassification</span></code> model has a classification head on top of the pretrained model outputs, which can be easily trained with the base model. We just need to specify how many labels the model has to predict (six in our case), since this dictates the number of outputs the classification head has:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># hide_output</span>
<span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">AutoModelForSequenceClassification</span>

<span class="n">num_labels</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">model</span> <span class="o">=</span> <span class="p">(</span><span class="n">AutoModelForSequenceClassification</span>
         <span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_ckpt</span><span class="p">,</span> <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">)</span>
         <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>You will see a warning that some parts of the model are randomly initialized. This is normal since the classification head has not yet been trained. The next step is to define the metrics that we’ll use to evaluate our model’s performance during fine-tuning.</p>
</section>
<section id="defining-the-performance-metrics">
<h4>Defining the performance metrics<a class="headerlink" href="#defining-the-performance-metrics" title="Permalink to this heading">#</a></h4>
<p>To monitor metrics during training, we need to define a <code class="docutils literal notranslate"><span class="pre">compute_metrics()</span></code> function for the <code class="docutils literal notranslate"><span class="pre">Trainer</span></code>.  This function receives an <code class="docutils literal notranslate"><span class="pre">EvalPrediction</span></code> object (which is a named tuple with <code class="docutils literal notranslate"><span class="pre">predictions</span></code> and <code class="docutils literal notranslate"><span class="pre">label_ids</span></code> attributes) and needs to return a dictionary that maps each metric’s name to its value. For our application, we’ll compute the <span class="math notranslate nohighlight">\(F_1\)</span>-score and the accuracy of the model as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">f1_score</span>

<span class="k">def</span> <span class="nf">compute_metrics</span><span class="p">(</span><span class="n">pred</span><span class="p">):</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">label_ids</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">predictions</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">f1_score</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">)</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">preds</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;accuracy&quot;</span><span class="p">:</span> <span class="n">acc</span><span class="p">,</span> <span class="s2">&quot;f1&quot;</span><span class="p">:</span> <span class="n">f1</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>With the dataset and metrics ready, we just have two final things to take care of before we define the <code class="docutils literal notranslate"><span class="pre">Trainer</span></code> class:</p>
<ol class="arabic simple">
<li><p>Log in to our account on the Hugging Face Hub. This will allow us to push our fine-tuned model to our account on the Hub and share it with the community.</p></li>
<li><p>Define all the hyperparameters for the training run.</p></li>
</ol>
<p>We’ll tackle these steps in the next section.</p>
</section>
<section id="training-the-model">
<h4>Training the model<a class="headerlink" href="#training-the-model" title="Permalink to this heading">#</a></h4>
<p>If you’re running this code in a Jupyter notebook, you can log in to the Hub with the following helper function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">huggingface_hub</span> <span class="kn">import</span> <span class="n">notebook_login</span>

<span class="n">notebook_login</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>This will display a widget in which you can enter your username and password, or an access token with write privileges. You can find details on how to create access tokens in the <a class="reference external" href="https://huggingface.co/docs/hub/security#user-access-tokens">Hub documentation</a>. If you’re working in the terminal, you can log in by running the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>huggingface-cli<span class="w"> </span>login
</pre></div>
</div>
<p>To define the training parameters, we use the <code class="docutils literal notranslate"><span class="pre">TrainingArguments</span></code> class. This class stores a lot of information and gives you fine-grained control over the training and evaluation. The most important argument to specify is <code class="docutils literal notranslate"><span class="pre">output_dir</span></code>, which is where all the artifacts from training are stored. Here is an example of <code class="docutils literal notranslate"><span class="pre">TrainingArguments</span></code> in all its glory:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">Trainer</span><span class="p">,</span> <span class="n">TrainingArguments</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">logging_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">])</span> <span class="o">//</span> <span class="n">batch_size</span>
<span class="n">model_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_ckpt</span><span class="si">}</span><span class="s2">-finetuned-emotion&quot;</span>
<span class="n">training_args</span> <span class="o">=</span> <span class="n">TrainingArguments</span><span class="p">(</span><span class="n">output_dir</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
                                  <span class="n">num_train_epochs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                  <span class="n">learning_rate</span><span class="o">=</span><span class="mf">2e-5</span><span class="p">,</span>
                                  <span class="n">per_device_train_batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                                  <span class="n">per_device_eval_batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                                  <span class="n">weight_decay</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                                  <span class="n">evaluation_strategy</span><span class="o">=</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span>
                                  <span class="n">disable_tqdm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">logging_steps</span><span class="o">=</span><span class="n">logging_steps</span><span class="p">,</span>
                                  <span class="n">push_to_hub</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                  <span class="n">log_level</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here we also set the batch size, learning rate, and number of epochs, and specify to load the best model at the end of the training run. With this final ingredient, we can instantiate and fine-tune our model with the <code class="docutils literal notranslate"><span class="pre">Trainer</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">Trainer</span>

<span class="n">trainer</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">training_args</span><span class="p">,</span> 
                  <span class="n">compute_metrics</span><span class="o">=</span><span class="n">compute_metrics</span><span class="p">,</span>
                  <span class="n">train_dataset</span><span class="o">=</span><span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">],</span>
                  <span class="n">eval_dataset</span><span class="o">=</span><span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;validation&quot;</span><span class="p">],</span>
                  <span class="n">tokenizer</span><span class="o">=</span><span class="n">tokenizer</span><span class="p">)</span>
<span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
    <div>
      
      <progress value='500' max='500' style='width:300px; height:20px; vertical-align: middle;'></progress>
      [500/500 01:48, Epoch 2/2]
    </div>
    <table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>Epoch</th>
      <th>Training Loss</th>
      <th>Validation Loss</th>
      <th>Accuracy</th>
      <th>F1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0.840900</td>
      <td>0.327445</td>
      <td>0.896500</td>
      <td>0.892285</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0.255000</td>
      <td>0.220472</td>
      <td>0.922500</td>
      <td>0.922550</td>
    </tr>
  </tbody>
</table><p></div></div>
</div>
<p>Looking at the logs, we can see that our model has an <span class="math notranslate nohighlight">\(F_1\)</span>-score on the validation set of around 92% - this is a significant improvement over the feature-based approach!</p>
<p>We can take a more detailed look at the training metrics by calculating the confusion matrix. To visualize the confusion matrix, we first need to get the predictions on the validation set. The <code class="docutils literal notranslate"><span class="pre">predict()</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Trainer</span></code> class returns several useful objects we can use for evaluation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># hide_output</span>
<span class="n">preds_output</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;validation&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
    <div>
      
      <progress value='32' max='32' style='width:300px; height:20px; vertical-align: middle;'></progress>
      [32/32 00:01]
    </div>
    </div></div>
</div>
<p>The output of the <code class="docutils literal notranslate"><span class="pre">predict()</span></code> method is a <code class="docutils literal notranslate"><span class="pre">PredictionOutput</span></code> object that contains arrays of <code class="docutils literal notranslate"><span class="pre">predictions</span></code> and <code class="docutils literal notranslate"><span class="pre">label_ids</span></code>, along with the metrics we passed to the trainer. For example, the metrics on the validation set can be accessed as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">preds_output</span><span class="o">.</span><span class="n">metrics</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;test_loss&#39;: 0.22047173976898193,
 &#39;test_accuracy&#39;: 0.9225,
 &#39;test_f1&#39;: 0.9225500751072866,
 &#39;test_runtime&#39;: 1.6357,
 &#39;test_samples_per_second&#39;: 1222.725,
 &#39;test_steps_per_second&#39;: 19.564}
</pre></div>
</div>
</div>
</div>
<p>It also contains the raw predictions for each class. We can decode the predictions greedily using <code class="docutils literal notranslate"><span class="pre">np.argmax()</span></code>. This yields the predicted labels and has the same format as the labels returned by the Scikit-Learn models in the feature-based approach:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y_preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">preds_output</span><span class="o">.</span><span class="n">predictions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With the predictions, we can plot the confusion matrix again:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_confusion_matrix</span><span class="p">(</span><span class="n">y_preds</span><span class="p">,</span> <span class="n">y_valid</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/40c4f82d375b7f52b894824a2e16988388e3ec5803901645345e7513e7093a92.svg" src="_images/40c4f82d375b7f52b894824a2e16988388e3ec5803901645345e7513e7093a92.svg" /></div>
</div>
<p>This is much closer to the ideal diagonal confusion matrix.  The <code class="docutils literal notranslate"><span class="pre">love</span></code> category is still often confused with <code class="docutils literal notranslate"><span class="pre">joy</span></code>, which seems natural. <code class="docutils literal notranslate"><span class="pre">surprise</span></code> is also frequently mistaken for <code class="docutils literal notranslate"><span class="pre">joy</span></code>, or confused with <code class="docutils literal notranslate"><span class="pre">fear</span></code>. Overall the performance of the model seems quite good, but before we call it a day, let’s dive a little deeper into the types of errors our model is likely to make.</p>
</section>
</section>
<section id="sidebar-fine-tuning-with-keras">
<h3>Sidebar: Fine-Tuning with Keras<a class="headerlink" href="#sidebar-fine-tuning-with-keras" title="Permalink to this heading">#</a></h3>
<p>If you are using TensorFlow, it’s also possible to fine-tune your models using the Keras API. The main difference from the PyTorch API is that there is no <code class="docutils literal notranslate"><span class="pre">Trainer</span></code> class, since Keras models already provide a built-in <code class="docutils literal notranslate"><span class="pre">fit()</span></code> method. To see how this works, let’s first load  DistilBERT as a TensorFlow model:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">TFAutoModelForSequenceClassification</span>

<span class="n">tf_model</span> <span class="o">=</span> <span class="p">(</span><span class="n">TFAutoModelForSequenceClassification</span>
            <span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_ckpt</span><span class="p">,</span> <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2021-10-29 15:33:36.938811: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library &#39;libcudnn.so.8&#39;; dlerror: libcudnn.so.8: cannot open shared object file: No such file or directory
2021-10-29 15:33:36.938844: W tensorflow/core/common_runtime/gpu/gpu_device.cc:1835] Cannot dlopen some GPU libraries. Please make sure the missing libraries mentioned above are installed properly if you would like to use GPU. Follow the guide at https://www.tensorflow.org/install/gpu for how to download and setup the required libraries for your platform.
Skipping registering GPU devices...
2021-10-29 15:33:36.939933: I tensorflow/core/platform/cpu_feature_guard.cc:142] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX2 AVX512F FMA
To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.
2021-10-29 15:33:36.962642: W tensorflow/python/util/util.cc:348] Sets are not currently considered sequences, but this may change in the future, so consider avoiding using them.
</pre></div>
</div>
</div>
</div>
<p>Next, we’ll convert our datasets into the <code class="docutils literal notranslate"><span class="pre">tf.data.Dataset</span></code> format. Since we have already padded our tokenized inputs, we can do this easily by applying the <code class="docutils literal notranslate"><span class="pre">to_tf_dataset()</span></code> method to <code class="docutils literal notranslate"><span class="pre">emotions_encoded</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The column names to convert to TensorFlow tensors</span>
<span class="n">tokenizer_columns</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">model_input_names</span>

<span class="n">tf_train_dataset</span> <span class="o">=</span> <span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_tf_dataset</span><span class="p">(</span>
    <span class="n">columns</span><span class="o">=</span><span class="n">tokenizer_columns</span><span class="p">,</span> <span class="n">label_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
<span class="n">tf_eval_dataset</span> <span class="o">=</span> <span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;validation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_tf_dataset</span><span class="p">(</span>
    <span class="n">columns</span><span class="o">=</span><span class="n">tokenizer_columns</span><span class="p">,</span> <span class="n">label_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here we’ve also shuffled the training set, and defined the batch size for it and the validation set. The last thing to do is compile and train the model:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>

<span class="n">tf_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">5e-5</span><span class="p">),</span>
    <span class="n">loss</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">SparseCategoricalCrossentropy</span><span class="p">(</span><span class="n">from_logits</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">metrics</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">SparseCategoricalAccuracy</span><span class="p">())</span>

<span class="n">tf_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tf_train_dataset</span><span class="p">,</span> <span class="n">validation_data</span><span class="o">=</span><span class="n">tf_eval_dataset</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2021-10-29 15:36:00.548707: I tensorflow/compiler/mlir/mlir_graph_optimization_pass.cc:185] None of the MLIR Optimization Passes are enabled (registered 2)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Epoch 1/2
250/250 [==============================] - 478s 2s/step - loss: 0.5379 - sparse_categorical_accuracy: 0.8138 - val_loss: 0.1452 - val_sparse_categorical_accuracy: 0.9430
Epoch 2/2
250/250 [==============================] - 471s 2s/step - loss: 0.1424 - sparse_categorical_accuracy: 0.9415 - val_loss: 0.1512 - val_sparse_categorical_accuracy: 0.9335
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;keras.callbacks.History&gt;
</pre></div>
</div>
</div>
</div>
</section>
<section id="id2">
<h3>End sidebar<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h3>
<section id="error-analysis">
<h4>Error analysis<a class="headerlink" href="#error-analysis" title="Permalink to this heading">#</a></h4>
<p>Before moving on, we should investigate our model’s predictions a little bit further. A simple yet powerful technique is to sort the validation samples by the model loss. When we pass the label during the forward pass, the loss is automatically calculated and returned. Here’s a function that returns the loss along with the predicted label:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torch.nn.functional</span> <span class="kn">import</span> <span class="n">cross_entropy</span>

<span class="k">def</span> <span class="nf">forward_pass_with_label</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
    <span class="c1"># Place all input tensors on the same device as the model</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">batch</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
              <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">model_input_names</span><span class="p">}</span>

    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">pred_label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">logits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">cross_entropy</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">logits</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> 
                             <span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>

    <span class="c1"># Place outputs on CPU for compatibility with other dataset columns   </span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;loss&quot;</span><span class="p">:</span> <span class="n">loss</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> 
            <span class="s2">&quot;predicted_label&quot;</span><span class="p">:</span> <span class="n">pred_label</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()}</span>
</pre></div>
</div>
</div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">map()</span></code> method once more, we can apply this function to get the losses for all the samples:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="c1"># Convert our dataset back to PyTorch tensors</span>
<span class="n">emotions_encoded</span><span class="o">.</span><span class="n">set_format</span><span class="p">(</span><span class="s2">&quot;torch&quot;</span><span class="p">,</span> 
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input_ids&quot;</span><span class="p">,</span> <span class="s2">&quot;attention_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">])</span>
<span class="c1"># Compute loss values</span>
<span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;validation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;validation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
    <span class="n">forward_pass_with_label</span><span class="p">,</span> <span class="n">batched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "6004443ac1344ee18d40c8a90c1178f4", "version_major": 2, "version_minor": 0}</script></div>
</div>
<p>Finally, we create a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with the texts, losses, and predicted/true labels:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">emotions_encoded</span><span class="o">.</span><span class="n">set_format</span><span class="p">(</span><span class="s2">&quot;pandas&quot;</span><span class="p">)</span>
<span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;predicted_label&quot;</span><span class="p">,</span> <span class="s2">&quot;loss&quot;</span><span class="p">]</span>
<span class="n">df_test</span> <span class="o">=</span> <span class="n">emotions_encoded</span><span class="p">[</span><span class="s2">&quot;validation&quot;</span><span class="p">][:][</span><span class="n">cols</span><span class="p">]</span>
<span class="n">df_test</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_test</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">label_int2str</span><span class="p">)</span>
<span class="n">df_test</span><span class="p">[</span><span class="s2">&quot;predicted_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_test</span><span class="p">[</span><span class="s2">&quot;predicted_label&quot;</span><span class="p">]</span>
                              <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">label_int2str</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We can now easily sort <code class="docutils literal notranslate"><span class="pre">emotions_encoded</span></code> by the losses in either ascending or descending order. The goal of this exercise is to detect one of the following:</p>
<ul class="simple">
<li><p><em>Wrong labels</em>:: Every process that adds labels to data can be flawed. Annotators can make mistakes or disagree, while labels that are inferred from other features can be wrong. If it was easy to automatically annotate data, then we would not need a model to do it. Thus, it is normal that there are some wrongly labeled examples. With this approach, we can quickly find and correct them.</p></li>
<li><p><em>Quirks of the dataset</em>:: Datasets in the real world are always a bit messy. When working with text, special characters or strings in the inputs can have a big impact on the model’s predictions. Inspecting the model’s weakest predictions can help identify such features, and cleaning the data or injecting similar examples can make the model more robust.</p></li>
</ul>
<p>Let’s first have a look at the data samples with the highest losses:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="n">df_test</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;loss&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>text</th>
      <th>label</th>
      <th>predicted_label</th>
      <th>loss</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1801</th>
      <td>i feel that he was being overshadowed by the s...</td>
      <td>love</td>
      <td>sadness</td>
      <td>5.704531</td>
    </tr>
    <tr>
      <th>1963</th>
      <td>i called myself pro life and voted for perry w...</td>
      <td>joy</td>
      <td>sadness</td>
      <td>5.484461</td>
    </tr>
    <tr>
      <th>1870</th>
      <td>i guess i feel betrayed because i admired him ...</td>
      <td>joy</td>
      <td>sadness</td>
      <td>5.434768</td>
    </tr>
    <tr>
      <th>882</th>
      <td>i feel badly about reneging on my commitment t...</td>
      <td>love</td>
      <td>sadness</td>
      <td>5.257482</td>
    </tr>
    <tr>
      <th>1950</th>
      <td>i as representative of everything thats wrong ...</td>
      <td>surprise</td>
      <td>sadness</td>
      <td>4.827708</td>
    </tr>
    <tr>
      <th>1509</th>
      <td>i guess this is a memoir so it feels like that...</td>
      <td>joy</td>
      <td>fear</td>
      <td>4.713047</td>
    </tr>
    <tr>
      <th>1274</th>
      <td>i am going to several holiday parties and i ca...</td>
      <td>joy</td>
      <td>sadness</td>
      <td>4.704955</td>
    </tr>
    <tr>
      <th>318</th>
      <td>i felt ashamed of these feelings and was scare...</td>
      <td>fear</td>
      <td>sadness</td>
      <td>4.656096</td>
    </tr>
    <tr>
      <th>1500</th>
      <td>i guess we would naturally feel a sense of lon...</td>
      <td>anger</td>
      <td>sadness</td>
      <td>4.593202</td>
    </tr>
    <tr>
      <th>1111</th>
      <td>im lazy my characters fall into categories of ...</td>
      <td>joy</td>
      <td>fear</td>
      <td>4.311287</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>We can clearly see that the model predicted some of the labels incorrectly. On the other hand, it seems that there are quite a few examples with no clear class, which might be either mislabeled or require a new class altogether. In particular, <code class="docutils literal notranslate"><span class="pre">joy</span></code> seems to be mislabeled several times. With this information we can refine the dataset, which often can lead to as big a performance gain (or more) as having more data or larger models!</p>
<p>When looking at the samples with the lowest losses, we observe that the model seems to be most confident when predicting the <code class="docutils literal notranslate"><span class="pre">sadness</span></code> class. Deep learning models are exceptionally good at finding and exploiting shortcuts to get to a prediction. For this reason, it is also worth investing time into looking at the examples that the model is most confident about, so that we can be confident that the model does not improperly exploit certain features of the text. So, let’s also look at the predictions with the smallest loss:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="n">df_test</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;loss&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>text</th>
      <th>label</th>
      <th>predicted_label</th>
      <th>loss</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>21</th>
      <td>i feel try to tell me im ungrateful tell me im...</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017331</td>
    </tr>
    <tr>
      <th>244</th>
      <td>im kinda relieve but at the same time i feel d...</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017392</td>
    </tr>
    <tr>
      <th>133</th>
      <td>i and feel quite ungrateful for it but i m loo...</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017400</td>
    </tr>
    <tr>
      <th>392</th>
      <td>i remember feeling disheartened one day when w...</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017461</td>
    </tr>
    <tr>
      <th>1310</th>
      <td>i feel like an ungrateful asshole</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017485</td>
    </tr>
    <tr>
      <th>189</th>
      <td>i leave the meeting feeling more than a little...</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017670</td>
    </tr>
    <tr>
      <th>1120</th>
      <td>i am feeling a little disheartened</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017685</td>
    </tr>
    <tr>
      <th>783</th>
      <td>i feel like i deserve to be broke with how fri...</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017888</td>
    </tr>
    <tr>
      <th>1368</th>
      <td>i started this blog with pure intentions i mus...</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017899</td>
    </tr>
    <tr>
      <th>1466</th>
      <td>i feel so ungrateful to be wishing this pregna...</td>
      <td>sadness</td>
      <td>sadness</td>
      <td>0.017913</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>We now know that the <code class="docutils literal notranslate"><span class="pre">joy</span></code> is sometimes mislabeled and that the model is most confident about predicting the label <code class="docutils literal notranslate"><span class="pre">sadness</span></code>. With this information we can make targeted improvements to our dataset, and also keep an eye on the class the model seems to be very confident about.</p>
<p>The last step before serving the trained model is to save it for later usage. image:images/logo.png[hf,13,13] Transformers allows us to do this in a few steps, which we’ll show you in the next section.</p>
</section>
<section id="saving-and-sharing-the-model">
<h4>Saving and sharing the model<a class="headerlink" href="#saving-and-sharing-the-model" title="Permalink to this heading">#</a></h4>
<p>The NLP community benefits greatly from sharing pretrained and fine-tuned models, and everybody can share their models with others via the Hugging Face Hub. Any community-generated model can be downloaded from the Hub just like we downloaded the DistilBERT model. With the <code class="docutils literal notranslate"><span class="pre">Trainer</span></code> API, saving and sharing a model is simple:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="n">trainer</span><span class="o">.</span><span class="n">push_to_hub</span><span class="p">(</span><span class="n">commit_message</span><span class="o">=</span><span class="s2">&quot;Training completed!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;https://huggingface.co/lewtun/distilbert-base-uncased-finetuned-emotion/commit/352c4147e4754f73a0b41f7b175f4a907270c9c9&#39;
</pre></div>
</div>
</div>
</div>
<p>We can also use the fine-tuned model to make predictions on new tweets. Since we’ve pushed our model to the Hub, we can now use it with the <code class="docutils literal notranslate"><span class="pre">pipeline()</span></code> function, just like we did in &lt;&lt;chapter_introduction&gt;&gt;. First, let’s load the pipeline:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#hide_output</span>
<span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">pipeline</span>

<span class="c1"># Change `transformersbook` to your Hub username</span>
<span class="n">model_id</span> <span class="o">=</span> <span class="s2">&quot;transformersbook/distilbert-base-uncased-finetuned-emotion&quot;</span>
<span class="n">classifier</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span><span class="s2">&quot;text-classification&quot;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model_id</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Then let’s test the pipeline with a sample tweet:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">custom_tweet</span> <span class="o">=</span> <span class="s2">&quot;I saw a movie today and it was really good.&quot;</span>
<span class="n">preds</span> <span class="o">=</span> <span class="n">classifier</span><span class="p">(</span><span class="n">custom_tweet</span><span class="p">,</span> <span class="n">return_all_scores</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can plot the probability for each class in a bar plot. Clearly, the model estimates that the most likely class is <code class="docutils literal notranslate"><span class="pre">joy</span></code>, which appears to be reasonable given the tweet:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">preds_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">preds_df</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">custom_tweet</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Class probability (%)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ce57955bbe8e2418aafd4aae1e373bac05d00328134c2e0e2dffd3a76b74a477.svg" src="_images/ce57955bbe8e2418aafd4aae1e373bac05d00328134c2e0e2dffd3a76b74a477.svg" /></div>
</div>
</section>
</section>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">#</a></h2>
<p>Congratulations, you now know how to train a transformer model to classify the emotions in tweets! We have seen two complementary approaches based on features and fine-tuning, and investigated their strengths and weaknesses.</p>
<p>However, this is just the first step in building a real-world application with transformer models, and we have a lot more ground to cover. Here’s a list of challenges you’re likely to experience in your NLP journey:</p>
<p>My boss wants my model in production yesterday!::
In most applications, your model doesn’t just sit somewhere gathering dust - you want to make sure it’s serving predictions! When a model is pushed to the Hub, an inference endpoint is automatically created that can be called with HTTP requests. We recommend checking out the <a class="reference external" href="https://api-inference.huggingface.co/docs/python/html/index.html">documentation</a> of the Inference API if you want to learn more.</p>
<p>My users want faster predictions!::
We’ve already seen one approach to this problem: using DistilBERT. In &lt;&lt;chapter_compression&gt;&gt; we’ll dive into knowledge distillation (the process by which DistilBERT was created), along with other tricks to speed up your transformer models.</p>
<p>Can your model also do X?::
As we’ve alluded to in this chapter, transformers are extremely versatile. In the rest of the book we will be exploring a range of tasks, like question answering and named entity recognition, all using the same basic architecture.</p>
<p>None of my texts are in English!::
It turns out that transformers also come in a multilingual variety, and we’ll use them in &lt;&lt;chapter_ner&gt;&gt; to tackle several languages at once.</p>
<p>I don’t have any labels!::
If there is very little labeled data available, fine-tuning may not be an option. In &lt;&lt;chapter_fewlabels&gt;&gt;, we’ll explore some techniques to deal with this situation.</p>
<p>Now that we’ve seen what’s involved in training and sharing a transformer, in the next chapter we’ll explore implementing our very own transformer model from scratch.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-dataset">The Dataset</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-first-look-at-hugging-face-datasets">A First Look at Hugging Face Datasets</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sidebar-what-if-my-dataset-is-not-on-the-hub">Sidebar: What If My Dataset Is Not on the Hub?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#end-sidebar">End sidebar</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-datasets-to-dataframes">From Datasets to DataFrames</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#looking-at-the-class-distribution">Looking at the Class Distribution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-long-are-our-tweets">How Long Are Our Tweets?</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#from-text-to-tokens">From Text to Tokens</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#character-tokenization">Character Tokenization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#word-tokenization">Word Tokenization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#subword-tokenization">Subword Tokenization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tokenizing-the-whole-dataset">Tokenizing the Whole Dataset</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#training-a-text-classifier">Training a Text Classifier</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transformers-as-feature-extractors">Transformers as Feature Extractors</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#using-pretrained-models">Using pretrained models</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sidebar-interoperability-between-frameworks">Sidebar: Interoperability Between Frameworks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">End sidebar</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#extracting-the-last-hidden-states">Extracting the last hidden states</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-feature-matrix">Creating a feature matrix</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#visualizing-the-training-set">Visualizing the training set</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#training-a-simple-classifier">Training a simple classifier</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fine-tuning-transformers">Fine-Tuning Transformers</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#loading-a-pretrained-model">Loading a pretrained model</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#defining-the-performance-metrics">Defining the performance metrics</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#training-the-model">Training the model</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sidebar-fine-tuning-with-keras">Sidebar: Fine-Tuning with Keras</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">End sidebar</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#error-analysis">Error analysis</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-and-sharing-the-model">Saving and sharing the model</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion">Conclusion</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Zeyu Lyu
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>